import slice
import ../stream
import ../utils/[convert]

import std/[sugar]



type
  SeqIndex* = csize_t

  SeqStep* = SliceStep[SeqIndex]



func indexes* [T](s: seq[T]): Stream[SeqStep, SeqIndex] =
  slice(s.low() as SeqIndex, s.high() as SeqIndex).items()


func items* [T](s: seq[T]): Stream[SeqStep, T] =
  s.indexes().map(i => s[i])


func pairs* [T](s: seq[T]): Stream[SeqStep, tuple[index: SeqIndex; item: T]] =
  s.indexes().map(i => (i, s[i]))



func indexes* (s: string): Stream[SeqStep, SeqIndex] =
  slice(s.low() as SeqIndex, s.high() as SeqIndex).items()


func chars* (s: string): Stream[SeqStep, char] =
  s.indexes().map(i => s[i])


func pairs* (s: string): Stream[SeqStep, tuple[index: SeqIndex; item: char]] =
  s.indexes().map(i => (i, s[i]))



when isMainModule:
  import ../monad/[io]
  import ../types/[somenatural]

  import std/[os, unittest]



  suite currentSourcePath().splitFile().name:
    test """Counting the number of items in a "seq[T]" should return its length.""":
      proc doTest [T](sequence: seq[T]) =
        let
          actual = sequence.items().count(BiggestUInt)
          expected = sequence.len() as actual.typeof()

        check:
          actual == expected


      doTest[string](@[])
      doTest(@['a', '5', 'b', '1'])



    test """All the items generated by "s.pairs()" should be equal to the index and item of "s" at that index.""":
      proc doTest [T](s: seq[T]) =
        let verified = s.pairs().all((it: (SeqIndex, T)) => it[1] == s[it[0]])

        check:
          verified


      doTest(@[0, 1, 3, 7, 6])



    test """Skip the first "n" items of a sequence and collect the rest at compile time.""":
      func skipAndCollect [T; N: SomeNatural](s: seq[T]; n: N): seq[T] =
        result = @[]

        for i in n ..< s.len().convert(N):
          result.add(s[i])


      proc doTest [T; N: SomeNatural](s: static seq[T]; n: static N) =
        const
          actual =
            s
              .items()
              .skip(n)
              .run()
              .reduce((res: seq[T], it: T) => res & it, @[])
          expected = s.skipAndCollect(n)

        check:
          actual == expected


      doTest(@[-5, -18, 0, 894, 135], 3u)
      doTest(@[].seq[:pointer], 2u)
      doTest(@["", "a", "0", "ab"], 0u)
